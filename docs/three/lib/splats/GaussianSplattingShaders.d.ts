/**
 * This file is part of mapbox-3d-tiles.
 * Copyright (c) 2024 Jianshun Yang
 * Licensed under the MIT License.
 * Source: https://github.com/yangjs6/mapbox-3d-tiles
 */
declare const vertexShaderSource = "\nprecision highp float;\n#include <common>\n\nattribute float splatIndex;\n\nuniform vec2 invViewport;\nuniform vec2 dataTextureSize;\nuniform vec2 focal;\nuniform sampler2D covariancesATexture;\nuniform sampler2D covariancesBTexture;\nuniform sampler2D centersTexture;\nuniform sampler2D colorsTexture;\n\n#if SH_DEGREE > 0\nuniform highp usampler2D shTexture0;\n#endif\n#if SH_DEGREE > 1\nuniform highp usampler2D shTexture1;\n#endif\n#if SH_DEGREE > 2\nuniform highp usampler2D shTexture2;\n#endif\n\nvarying vec4 vColor;\nvarying vec2 vPosition;\n\nvec2 getDataUV(float index, vec2 textureSize) {\n    float y = floor(index / textureSize.x);\n    float x = index - y * textureSize.x;\n    return vec2((x + 0.5) / textureSize.x, (y + 0.5) / textureSize.y);\n}\n\n#if SH_DEGREE > 0\nivec2 getDataUVint(float index, vec2 textureSize) {\n    float y = floor(index / textureSize.x);\n    float x = index - y * textureSize.x;\n    return ivec2(uint(x + 0.5), uint(y + 0.5));\n}\n#endif\n\nstruct Splat {\n    vec4 center;\n    vec4 color;\n    vec4 covA;\n    vec4 covB;\n#if SH_DEGREE > 0\n    uvec4 sh0;\n#endif\n#if SH_DEGREE > 1\n    uvec4 sh1;\n#endif\n#if SH_DEGREE > 2\n    uvec4 sh2;\n#endif\n};\n\nSplat readSplat(float splatIndex) {\n    Splat splat;\n    vec2 splatUV = getDataUV(splatIndex, dataTextureSize);\n    splat.center = texture2D(centersTexture, splatUV);\n    splat.color = texture2D(colorsTexture, splatUV);\n    splat.covA = texture2D(covariancesATexture, splatUV) * splat.center.w;\n    splat.covB = texture2D(covariancesBTexture, splatUV) * splat.center.w;\n#if SH_DEGREE > 0\n    ivec2 splatUVint = getDataUVint(splatIndex, dataTextureSize);\n    splat.sh0 = texelFetch(shTexture0, splatUVint, 0);\n#endif\n#if SH_DEGREE > 1\n    splat.sh1 = texelFetch(shTexture1, splatUVint, 0);\n#endif\n#if SH_DEGREE > 2\n    splat.sh2 = texelFetch(shTexture2, splatUVint, 0);\n#endif\n    return splat;\n}\n\nvec3 computeColorFromSHDegree(vec3 dir, const vec3 sh[16]) {\n    const float SH_C0 = 0.28209479;\n    const float SH_C1 = 0.48860251;\n    float SH_C2[5];\n    SH_C2[0] = 1.092548430;\n    SH_C2[1] = -1.09254843;\n    SH_C2[2] = 0.315391565;\n    SH_C2[3] = -1.09254843;\n    SH_C2[4] = 0.546274215;\n    \n    float SH_C3[7];\n    SH_C3[0] = -0.59004358;\n    SH_C3[1] = 2.890611442;\n    SH_C3[2] = -0.45704579;\n    SH_C3[3] = 0.373176332;\n    SH_C3[4] = -0.45704579;\n    SH_C3[5] = 1.445305721;\n    SH_C3[6] = -0.59004358;\n\n    vec3 result = sh[0];\n\n#if SH_DEGREE > 0\n    float x = dir.x;\n    float y = dir.y;\n    float z = dir.z;\n    result += -SH_C1 * y * sh[1] + SH_C1 * z * sh[2] - SH_C1 * x * sh[3];\n\n#if SH_DEGREE > 1\n    float xx = x * x, yy = y * y, zz = z * z;\n    float xy = x * y, yz = y * z, xz = x * z;\n    result += \n        SH_C2[0] * xy * sh[4] +\n        SH_C2[1] * yz * sh[5] +\n        SH_C2[2] * (2.0f * zz - xx - yy) * sh[6] +\n        SH_C2[3] * xz * sh[7] +\n        SH_C2[4] * (xx - yy) * sh[8];\n\n#if SH_DEGREE > 2\n    result += \n        SH_C3[0] * y * (3.0f * xx - yy) * sh[9] +\n        SH_C3[1] * xy * z * sh[10] +\n        SH_C3[2] * y * (4.0f * zz - xx - yy) * sh[11] +\n        SH_C3[3] * z * (2.0f * zz - 3.0f * xx - 3.0f * yy) * sh[12] +\n        SH_C3[4] * x * (4.0f * zz - xx - yy) * sh[13] +\n        SH_C3[5] * z * (xx - yy) * sh[14] +\n        SH_C3[6] * x * (xx - 3.0f * yy) * sh[15];\n#endif\n#endif\n#endif\n\n    return result;\n}\n\nvec4 decompose(uint value) {\n    vec4 components = vec4(\n        float((value) & 255u),\n        float((value >> uint(8)) & 255u),\n        float((value >> uint(16)) & 255u),\n        float((value >> uint(24)) & 255u)\n    );\n    return components * vec4(2./255.) - vec4(1.);\n}\n\nvec3 computeSH(Splat splat, vec3 color, vec3 dir) {\n    vec3 sh[16];\n    sh[0] = color;\n\n#if SH_DEGREE > 0\n    vec4 sh00 = decompose(splat.sh0.x);\n    vec4 sh01 = decompose(splat.sh0.y);\n    vec4 sh02 = decompose(splat.sh0.z);\n    sh[1] = vec3(sh00.x, sh00.y, sh00.z);\n    sh[2] = vec3(sh00.w, sh01.x, sh01.y);\n    sh[3] = vec3(sh01.z, sh01.w, sh02.x);\n#endif\n#if SH_DEGREE > 1\n    vec4 sh03 = decompose(splat.sh0.w);\n    vec4 sh04 = decompose(splat.sh1.x);\n    vec4 sh05 = decompose(splat.sh1.y);\n    sh[4] = vec3(sh02.y, sh02.z, sh02.w);\n    sh[5] = vec3(sh03.x, sh03.y, sh03.z);\n    sh[6] = vec3(sh03.w, sh04.x, sh04.y);\n    sh[7] = vec3(sh04.z, sh04.w, sh05.x);\n    sh[8] = vec3(sh05.y, sh05.z, sh05.w);\n#endif\n#if SH_DEGREE > 2\n    vec4 sh06 = decompose(splat.sh1.z);\n    vec4 sh07 = decompose(splat.sh1.w);\n    vec4 sh08 = decompose(splat.sh2.x);\n    vec4 sh09 = decompose(splat.sh2.y);\n    vec4 sh10 = decompose(splat.sh2.z);\n    vec4 sh11 = decompose(splat.sh2.w);\n    sh[9] = vec3(sh06.x, sh06.y, sh06.z);\n    sh[10] = vec3(sh06.w, sh07.x, sh07.y);\n    sh[11] = vec3(sh07.z, sh07.w, sh08.x);\n    sh[12] = vec3(sh08.y, sh08.z, sh08.w);\n    sh[13] = vec3(sh09.x, sh09.y, sh09.z);\n    sh[14] = vec3(sh09.w, sh10.x, sh10.y);\n    sh[15] = vec3(sh10.z, sh10.w, sh11.x);\n#endif\n\n    return computeColorFromSHDegree(dir, sh);\n}\n\nvec4 gaussianSplatting(vec2 meshPos, vec3 worldPos, vec2 scale, vec3 covA, vec3 covB, mat4 worldMatrix, mat4 viewMatrix, mat4 projectionMatrix) {\n    mat4 modelView = viewMatrix * worldMatrix;\n    vec4 camspace = viewMatrix * vec4(worldPos, 1.0);\n    vec4 pos2d = projectionMatrix * camspace;\n\n    float bounds = 1.2 * pos2d.w;\n    if (pos2d.z < -pos2d.w || pos2d.x < -bounds || pos2d.x > bounds || pos2d.y < -bounds || pos2d.y > bounds) {\n        return vec4(0.0, 0.0, 2.0, 1.0);\n    }\n\n    mat3 Vrk = mat3(\n        covA.x, covA.y, covA.z,\n        covA.y, covB.x, covB.y,\n        covA.z, covB.y, covB.z\n    );\n\n    mat3 J = mat3(\n        focal.x / camspace.z, 0., -(focal.x * camspace.x) / (camspace.z * camspace.z),\n        0., focal.y / camspace.z, -(focal.y * camspace.y) / (camspace.z * camspace.z),\n        0., 0., 0.\n    );\n\n    mat3 T = transpose(mat3(modelView)) * J;\n    mat3 cov2d = transpose(T) * Vrk * T;\n\n    float mid = (cov2d[0][0] + cov2d[1][1]) / 2.0;\n    float radius = length(vec2((cov2d[0][0] - cov2d[1][1]) / 2.0, cov2d[0][1]));\n    float lambda1 = mid + radius, lambda2 = mid - radius;\n\n    if (lambda2 < 0.0) {\n        return vec4(0.0, 0.0, 2.0, 1.0);\n    }\n\n    vec2 diagonalVector = normalize(vec2(cov2d[0][1], lambda1 - cov2d[0][0]));\n    vec2 majorAxis = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;\n    vec2 minorAxis = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);\n\n    vec2 vCenter = vec2(pos2d);\n    return vec4(\n        vCenter + ((meshPos.x * majorAxis + meshPos.y * minorAxis) * invViewport * pos2d.w) * scale,\n        pos2d.zw\n    );\n}\n\nvoid main() {\n    Splat splat = readSplat(splatIndex);\n    vec3 covA = splat.covA.xyz;\n    vec3 covB = vec3(splat.covA.w, splat.covB.xy);\n\n    vec4 worldPos = modelMatrix * vec4(splat.center.xyz, 1.0);\n\n    vColor = splat.color;\n    vPosition = position.xy;\n\n    gl_Position = gaussianSplatting(vPosition, worldPos.xyz, vec2(1.0, 1.0), covA, covB, modelMatrix, viewMatrix, projectionMatrix);\n}\n";
declare const fragmentShaderSource = "\nprecision highp float;\n#include <common>\n\nvarying vec4 vColor;\nvarying vec2 vPosition;\n\nvec4 gaussianColor(vec4 inColor) {\n    float A = -dot(vPosition, vPosition);\n    if (A < -4.0) discard;\n    float B = exp(A) * inColor.a;\n    return vec4(inColor.rgb, B);\n}\n\nvoid main() {\n    gl_FragColor = gaussianColor(vColor);\n}\n";
export { vertexShaderSource, fragmentShaderSource };
//# sourceMappingURL=GaussianSplattingShaders.d.ts.map